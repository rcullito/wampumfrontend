<blogheader></blogheader>

<div class="container lower">
  <span class="row">
    <span class="col-sm-3">
      <h4 style="text-transform:underline;">Archive</h4>
            <div ng-repeat="blog in blogs">
          <p><a class="blog-link" href="/blog/{{ blog.written }}">{{ blog.title }}</a></p>
        </div>
    </span>
    <span id="blogText" class="col-sm-9">
    <h2>Fuzzy... Queries 5/5/14</h2>

    <p>This post recaps a few of the intial Elastic Search Queries in place at Wampum, and ends with what I consider to be a sensible default that can hopefully serve as a model for other projects looking to get up and running fast with Elastic Search across their data set.</p>

    <p>A few links have been sprinkled around Quora and Reddit over the last week to get some intial traffic to Wampum. It has been incredibly helpful to see what people are interested in searching for! With increased traffic come a helpful host of examples, and it has been enlightening to see where the bolts have needed to be tightened down!</p>


    <h4>Prefix Query</h4>

    <p>To start out, Wampum was using a simple prefixQuery, which would return results as long as the few characters that were typed into the search bar were also included at the beginning of the words indexed in ElasticSearch. This worked great intially, as typing in just "so", would yield "socks" or "solar panel". The problem with this approach is that over the weekend a search for "car" would bring up hits for "cards" and "caring", and things started to get confusing fast.</p>

    <h4>Term Query</h4>

     <p>The intial fix was to just implement a term query, which is the elasticsearch equivalent of a scalpel that will only cut out the terms that match exactly what you searched for. If you typed in "car", you would just see results for "car" and nothing to do with "cards", and if you typed "cards", you would be shielded from all of the vehicle related results. This approach was a nice reminder that simplicty is key, and while it is nice to guess what the user might have meant, there are still many cases when they know exactly what they want, and its important to make sure that the results give it to them.</p>

     <h4>Fuzzy Query</h4>

     <p>Fuzzy queries seemed liked they might be an interesting feature to check out. To find out more about the underlying mechanism behind them, check out <a href="http://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a>.  If you clicked on the Wikipedia link, you now already know that the levenshtein distance between the words "books" and "boots" is 1. This is just another way of saying that all you have to do to make  your pair of "boots" a pair of "books" is to swap out a "t" for a "k". Let's say you wanted to swap out "boots" for just "book", then you would have a levenshtein distance of 2: 1 for changing the "T" to a "K", and one for dropping the trailing "S".</p>

     <p>While this seemed like the perfect swiss army knife for the job, I found the way that Elasticsearch implements Levenshtein distance to be a bit counterintuitive. 

     What Elasticsearch does before executing the query is find all of the terms that satisfy the Levenshtien distance count you pass up in the parameters, and then execute a query for all of those as if they are equals. So while fuzzy queries are perfect for catching mispellings, in the above example a search for boots has an equal probability of returning <i>books</i> as the first hit in your <i>boots</i> search, as it does as returning a location where you can drop off your <i>boots</i>.</p>

     <h4>Multiple Queries: 1 Term, 1 Fuzzy. Score the Term Higher</h4>

    <p>Putting together the best parts of the above, the problem can be solved by using two queries, one for an exact search, and one for a fuzzy search. From what I've been trying so far, Elasticsearch seems to handle the scoring pretty appropriately such that the exact term you entered is the highest result, followed by the fuzzier ones. Enough with the chatter, here is a working implementation.</p>

    <gist id="cd4513766e112387b9c8"></gist>

    <p>This seems like a pretty sane default for now, and is defintely a step up over the prefixQuery that was in place. Many thanks to everyone who has been searching already as it has been a great impetus to drive the underlying technology forward!</p>


    </span>
    <div class="col-sm-9 col-sm-offset-3">
      <div disqus="disqus_thread"></div>
    </div>
  </span>
</div>



