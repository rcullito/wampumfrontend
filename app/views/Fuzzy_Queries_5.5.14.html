<blogheader></blogheader>

<div class="container lower">
  <span class="row">
    <span class="col-sm-3">
      <h4 style="text-transform:underline;">Archive</h4>
            <div ng-repeat="blog in blogs">
          <p><a class="blog-link" href="/blog/{{ blog.written }}">{{ blog.title }}</a></p>
        </div>
    </span>
    <span id="blogText" class="col-sm-9">
    <h3>Fuzzy Queries 5/5/14</h3><p>A few links have been sprinkled around Quora and Reddit over the last week to get some intial traffic to Wampum while I am still honing down the search feature. It has been incredibly helpful to see what people are interested in searching for! With more search volume, it was defintely time to upgrade some of the Elasticsearch syntax behind Wampum's results.</p><p>To start out, there was a simple prefixQuery, which would return results as long as the few characters that were typed into the search bar were also included at the beginning of the words indexed in ElasticSearch. This worked great intially, as typing in just "so", would yield "socks" or "solar panel". The problem with this approach is that over the weekend a search for "car" would bring up hits for "cards" and "caring", and things started to get confusing fast. </p><p>The intial fix was to just implement a term query, which didn't try anything fancy with guessing which word someone was trying to type, but it got the job done. If you typed in "car", you would just see results for "car" and nothing to do with "cards", and if you typed "cards", you would be shielded from all of the vehicle related results. Pretty simple right?</p><p>This approach, while technically straightforward, was something I still found to be lacking given what Wampum is a forgiving creature by nature. Fuzzy queries seemed liked they might be an interesting feature to check out. To find out more about the underlying mechanism behind them, check out <a href="http://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a>.  If you clicked on the Wikipedia link, you now already know that the levenshtein distance between books and boots is one. This is a really obnoxious way of saying that all you have to do to make  your pair of "boots" a pair of "books" is to swap out a "t" for a "k". Let's say you wanted to swap out a pair of boots for a single book, then you would have a levenshtein distance of 2. 1 for changing the "T" to a "K", and one for dropping the trailing "S".</p><p>While this seemed like the perfect swiss army knife for the job, I found the way that Elasticsearch implements Levenshtein distance to be a bit counterintuitive. In effect, the ES team is pretty democratic about its implementation. The example I came across had to do with "books" and "boots", both terms that one can search for currently on Wampum, and find a location for. What Elasticsearch does before executing the query is find all of the terms that satisfy the Levenshtien distance count you pass up in the parameters(I set mine to 1), and then execute a query for all of those as if they are equals. In my mind, this is an ideal case if you mispel a word, but not for dealing with words that are all valid, but just happen to have similar spellings. For instance, in the Levenshtein world, if I menat to search "dog", but instead typed  "dgo", then the worst that would happen is that it probably wouldn't find anything named "dgo", it would find results for "dog", and we could all high five over things.  But in the "books" and "boots" example, the problem is that if you search for one of them, both results will come back as equals. This can pretty confusing from a user's point of view, especially if the first result you see is for the wrong term. </p><p>So in effect, you have to use two queries, one for an exact search, and one for a fuzzy search. From what I've been trying so far, Elasticsearch seems to handle the scoring pretty appropriately such that the exact term you entered is the highest result, followed by the fuzzier ones. Enough with the chatter, here is a working implementation which I was unable to find anywhere online, so hopefully it is of use to someone.</p><gist id="cd4513766e112387b9c8"></gist><p>This seems like a pretty sane default for now, and is defintely a step up over the prefixQuery that was in place. Many thanks to everyone who has been searching already as it has been a great impetus to drive the underlying technology forward!</p>
    </span>
    <div class="col-sm-9 col-sm-offset-3">
      <div disqus="disqus_thread"></div>
    </div>
  </span>
</div>



